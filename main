import random

class Card:
    def __init__(self, suit, rank):
        self.suit = suit
        self.rank = rank

    def __repr__(self):
        return f"{self.rank}{self.suit}"

class Deck:
    def __init__(self):
        suits = ['♠', '♥', '♦', '♣']  # Spades, Hearts, Diamonds, Clubs
        ranks = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A']
        self.cards = [Card(suit, rank) for suit in suits for rank in ranks]

    def shuffle(self):
        random.shuffle(self.cards)

    def deal(self, num_cards):
        if num_cards > len(self.cards):
            raise ValueError("Not enough cards left to deal.")
        dealt_cards = self.cards[:num_cards]
        self.cards = self.cards[num_cards:]
        return dealt_cards

def evaluate_hand(hand):
    """Evaluate the strength of a poker hand."""
    rank_order = {str(i): i for i in range(2, 11)}
    rank_order.update({"J": 11, "Q": 12, "K": 13, "A": 14})

    # Sort cards by rank
    sorted_hand = sorted(hand, key=lambda card: rank_order[card.rank], reverse=True)

    # Count occurrences of each rank
    rank_counts = {}
    for card in hand:
        rank_counts[card.rank] = rank_counts.get(card.rank, 0) + 1

    counts = list(rank_counts.values())
    is_flush = len(set(card.suit for card in hand)) == 1
    is_straight = (
        len(rank_counts) == len(hand) and 
        rank_order[sorted_hand[0].rank] - rank_order[sorted_hand[-1].rank] == len(hand) - 1
    )

    if is_straight and is_flush:
        return "Straight Flush"
    elif 4 in counts:
        return "Four of a Kind"
    elif 3 in counts and 2 in counts:
        return "Full House"
    elif is_flush:
        return "Flush"
    elif is_straight:
        return "Straight"
    elif 3 in counts:
        return "Three of a Kind"
    elif counts.count(2) == 2:
        return "Two Pair"
    elif 2 in counts:
        return "One Pair"
    else:
        return "High Card"

def simulate_win_probability(player_hand, opponents_hands, num_simulations=1000):
    """Simulate win probabilities using Monte Carlo simulations."""
    wins = 0
    ties = 0

    for _ in range(num_simulations):
        # Create a new deck for each simulation
        deck = Deck()
        # Remove cards already in play
        in_play = player_hand + [card for hand in opponents_hands for card in hand]
        deck.cards = [card for card in deck.cards if card not in in_play]
        deck.shuffle()

        # Deal community cards
        try:
            community_cards = deck.deal(5)
        except ValueError:
            continue  # Skip simulation if not enough cards

        player_final_hand = player_hand + community_cards
        opponent_final_hands = [hand + community_cards for hand in opponents_hands]

        player_rank = evaluate_hand(player_final_hand)
        opponent_ranks = [evaluate_hand(opponent_hand) for opponent_hand in opponent_final_hands]

        if all(player_rank > opponent_rank for opponent_rank in opponent_ranks):
            wins += 1
        elif any(player_rank == opponent_rank for opponent_rank in opponent_ranks):
            ties += 1

    total_simulations = num_simulations
    win_probability = (wins / total_simulations) * 100
    tie_probability = (ties / total_simulations) * 100

    return win_probability, tie_probability

def main():
    # Ask for the number of opponents
    while True:
        try:
            num_opponents = int(input("Enter the number of opponents (1-8): "))
            if 1 <= num_opponents <= 8:
                break
            else:
                print("Please enter a number between 1 and 8.")
        except ValueError:
            print("Invalid input. Please enter a number between 1 and 8.")

    # Create and shuffle the deck
    deck = Deck()
    deck.shuffle()

    # Deal two cards to the player
    player_hand = deck.deal(2)
    print("Player's Hand:", player_hand)

    # Deal two cards to each opponent
    opponents_hands = [deck.deal(2) for _ in range(num_opponents)]
    for i, hand in enumerate(opponents_hands, start=1):
        print(f"Opponent {i}'s Hand:", hand)

    # Simulate win probabilities
    win_prob, tie_prob = simulate_win_probability(player_hand, opponents_hands)
    print(f"Win Probability: {win_prob:.2f}%")
    print(f"Tie Probability: {tie_prob:.2f}%")

if __name__ == "__main__":
    main()
